{"version":3,"file":"index.js","mappings":"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","sources":["webpack://oslash-be/webpack/bootstrap","webpack://oslash-be/webpack/runtime/compat get default export","webpack://oslash-be/webpack/runtime/define property getters","webpack://oslash-be/webpack/runtime/hasOwnProperty shorthand","webpack://oslash-be/external commonjs \"express\"","webpack://oslash-be/external commonjs \"cors\"","webpack://oslash-be/external commonjs \"helmet\"","webpack://oslash-be/external commonjs \"morgan\"","webpack://oslash-be/external node-commonjs \"fs\"","webpack://oslash-be/external node-commonjs \"path\"","webpack://oslash-be/external commonjs \"express-session\"","webpack://oslash-be/external commonjs \"dotenv\"","webpack://oslash-be/./src/config/cache.config.ts","webpack://oslash-be/./src/config/db.config.ts","webpack://oslash-be/./src/config/session.config.ts","webpack://oslash-be/./src/config/app.config.ts","webpack://oslash-be/./src/config/index.ts","webpack://oslash-be/external commonjs \"ioredis\"","webpack://oslash-be/external commonjs \"connect-redis\"","webpack://oslash-be/./src/services/redis/redis.service.ts","webpack://oslash-be/external commonjs \"joi\"","webpack://oslash-be/external commonjs \"bcryptjs\"","webpack://oslash-be/external commonjs \"bcrypt\"","webpack://oslash-be/external commonjs \"@prisma/client\"","webpack://oslash-be/./src/services/auth/auth.service.ts","webpack://oslash-be/./src/controllers/auth/auth.controller.ts","webpack://oslash-be/./src/routes/auth/auth.route.ts","webpack://oslash-be/./src/index.ts","webpack://oslash-be/./src/app.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"express\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"cors\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"helmet\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"morgan\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"express-session\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"dotenv\");","import { RedisOptions } from \"ioredis\";\n\nconst {\n  REDIS_PORT = 6379,\n  REDIS_HOST = \"localhost\", //also references as REDIS_URL //using redis as value defaults to the docker image that we have\n  REDIS_PASSWORD = \"secret\",\n} = process.env;\n\nexport const REDIS_OPTIONS: RedisOptions = {\n  port: +REDIS_PORT,\n  host: REDIS_HOST,\n  password: REDIS_PASSWORD,\n};\n","export const {\n  POSTGRESQL_USER = \"admin\",\n  POSTGRESQL_PASSWORD = \"admin\",\n  POSTGRESQL_PORT = \"5432\",\n  POSTGRESQL_HOST = \"localhost\",\n} = process.env;\n\nexport const {\n  DATABASE_URL = `postgres://${POSTGRESQL_USER}:${POSTGRESQL_PASSWORD}@${POSTGRESQL_HOST}:${POSTGRESQL_PORT}`,\n} = process.env;\n","import { SessionOptions } from \"express-session\";\n\nconst SIX_HOURS = 1000 * 60 * 60 * 6;\n\nconst {\n  SESSION_SECRET = \"secret\",\n  SESSION_NAME = \"sid\",\n  SESSION_TIMEOUT = SIX_HOURS,\n} = process.env;\n\nexport const SESSION_OPTIONS: SessionOptions = {\n  secret: SESSION_SECRET,\n  name: SESSION_NAME,\n  cookie: {\n    maxAge: +SESSION_TIMEOUT,\n    secure: true,\n  },\n  resave: false,\n  saveUninitialized: false,\n  rolling: true, //roll the session i.e. keep it alive even after six hours if the user is active\n};\n","export const { NODE_ENV, PORT } = process.env;\n","import { config } from \"dotenv\";\nconfig();\n\nexport * from \"./cache.config\";\nexport * from \"./db.config\";\nexport * from \"./session.config\";\nexport * from \"./app.config\";\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ioredis\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"connect-redis\");","import Redis from \"ioredis\";\nimport connectRedis, { RedisStore } from \"connect-redis\";\nimport { REDIS_OPTIONS } from \"../../config\";\nimport session from \"express-session\";\n\nclass ConfigureRedis {\n  private RedisStore: RedisStore;\n  private redisClient: Redis;\n\n  constructor () {\n    //connectRedis is a class that makes use of express-session's session to connect to redis\n    this.RedisStore = connectRedis(session);\n\n    //configure a new redis client from ioredis\n    this.redisClient = new Redis(REDIS_OPTIONS);\n\n    this.redisClient.on(\"error\", () => {\n      throw \"Error connecting with redis client\";\n    });\n  }\n\n  /**\n   * @returns a new redis store to work with the express-session middleware\n   */\n  public get redisStore (): RedisStore {\n    //creating a new instance of redis store class with our pre-configured redis client\n    return new this.RedisStore({ client: this.redisClient });\n  }\n}\n\nexport default ConfigureRedis;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"joi\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bcryptjs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bcrypt\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@prisma/client\");","import { genSalt } from \"bcryptjs\";\nimport { compare, hash } from \"bcrypt\";\nimport { PrismaClient, User } from \"@prisma/client\";\nimport { ServiceError, UserRegistrationData } from \"../../interfaces\";\n\nclass AuthService {\n  private prisma: PrismaClient;\n\n  constructor () {\n    this.prisma = new PrismaClient();\n  }\n\n  /**\n   *\n   * @param password - password recieved via POST request\n   * @returns password hashed with a salt of 10\n   */\n  private encryptPassword = async (\n    password: string,\n  ): Promise<string> => {\n    const salt = await genSalt(10);\n    const hashedPassword = await hash(password, salt);\n    return hashedPassword;\n  };\n\n  /**\n   *\n   * @param userPassword - password recieved via POST request\n   * @param dbPassword - password stored in the database\n   * @returns\n   */\n  private comparePassword = (\n    userPassword: string,\n    dbPassword: string,\n  ): Promise<boolean> => {\n    return compare(userPassword, dbPassword);\n  };\n\n  /**\n   *\n   * @param email - user email\n   * @returns - Promise that either resolves to the user data or null\n   */\n  private getUserFromEmail = (\n    email: string,\n  ): Promise<User | null> => {\n    return new Promise<User | null>((resolve, reject) => {\n      /**\n       * IIFE to prevent the application from let go of errors\n       */\n      (async () => {\n        try {\n          const user = await this.prisma.user.findUnique({\n            where: {\n              email,\n            },\n          });\n          return resolve(user);\n        } catch (error) {\n          return reject(error);\n        }\n      })();\n    });\n  };\n\n  /**\n   *\n   * @param data - name, email, password recieved in request body\n   * @returns\n   */\n  public register = (data: UserRegistrationData): Promise<string> => {\n    const { email } = data;\n\n    return new Promise<string>((resolve, reject) => {\n      /**\n       * async IIFE - to escape promise executor function being async\n       * this is necessary to catch errors\n       */\n      (async () => {\n        try {\n          const user = await this.getUserFromEmail(email);\n\n          /**\n           * If the user with the same email exists, do not register the user\n           */\n          if (user) {\n            return reject({\n              error: \"User with this email already exists\",\n              code: 409,\n            } as ServiceError);\n          }\n\n          /**\n           * Encrypting the password before saving it in the DB\n           */\n          data.password = await this.encryptPassword(data.password);\n\n          /**\n           * Creating a new user with the data provided in the API request\n           */\n          const { id } = await this.prisma.user.create({\n            data,\n          });\n          return resolve(id);\n        } catch (error) {\n          return reject({\n            error,\n            code: 503,\n          } as ServiceError);\n        }\n      })();\n    });\n  };\n}\n\nexport default AuthService;\n","import { Request, Response } from \"express\";\nimport Joi, { ValidationError, ValidationResult } from \"joi\";\nimport {\n  GeneralApiResponse,\n  ServiceError,\n  UserRegistrationData,\n} from \"../../interfaces\";\nimport AuthService from \"../../services/auth/auth.service\";\n\nclass AuthController {\n  private authService;\n\n  constructor () {\n    this.authService = new AuthService();\n  }\n\n  /**\n   *\n   * @param userRegistrationData - an object with name, email, and password => required for registration\n   * @returns - ValidationResult with error message\n   */\n  private validateRegistrationData = (\n    userRegistrationData: UserRegistrationData,\n  ): ValidationResult => {\n    const schema = Joi.object({\n      name: Joi.string()\n        .min(3)\n        .max(64)\n        .trim()\n        .required(),\n      email: Joi.string()\n        .email()\n        .max(128)\n        .lowercase()\n        .trim()\n        .required(),\n      password: Joi.string()\n        .min(6)\n        .max(256)\n        .required(),\n    });\n\n    return schema.validate(userRegistrationData);\n  };\n\n  /**\n   *\n   * @param req Express request\n   * @param res Express response\n   * @returns res.status.json({...})\n   */\n  public register = async (req: Request, res: Response) => {\n    /**\n     * validating user registration data and sanitizing the req body\n     */\n    const userRegistrationData: UserRegistrationData = req.body;\n\n    const validationError:\n      | ValidationError\n      | null\n      | undefined = this.validateRegistrationData(\n      userRegistrationData,\n    ).error;\n\n    /**\n     * If there are no validation errors, register the user\n     * Else, notify via API response\n     */\n    if (!validationError) {\n      try {\n        const id = await this.authService.register(\n          userRegistrationData,\n        );\n        return res.status(201).json({\n          error: null,\n          data: {\n            userId: id,\n          },\n        });\n      } catch (serviceError) {\n        const {\n          error,\n          code,\n        }: ServiceError = serviceError as ServiceError;\n\n        /**\n         * Using the response code recieved from AuthService\n         */\n        return res.status(+code).json({\n          error,\n          data: null,\n        } as GeneralApiResponse);\n      }\n    } else {\n      return res.status(403).json({\n        error: validationError.message,\n        data: null,\n      } as GeneralApiResponse);\n    }\n  };\n}\n\nexport default AuthController;\n","import { Router, Request, Response } from \"express\";\nimport AuthController from \"../../controllers/auth/auth.controller\";\nimport { GeneralApiResponse } from \"../../interfaces\";\n\nclass AuthRoute {\n  private path: string = \"/\";\n  public router: Router;\n  private authController;\n\n  constructor () {\n    this.router = Router();\n    this.authController = new AuthController();\n\n    //initializing all the authentication routes\n    this.initializeRoute();\n  }\n\n  private initializeRoute = (): void => {\n    //base route to check route health\n    this.router.get(`${this.path}`, (req: Request, res: Response) => {\n      res.status(200).json({\n        error: null,\n        data: \"User auth route - healthy\",\n      } as GeneralApiResponse);\n    });\n\n    //post route to register the user\n    this.router.post(\n      `${this.path}register`,\n      (req: Request, res: Response) => {\n        //request forwarding to handle the request elements in the AuthController\n        this.authController.register(req, res);\n      },\n    );\n  };\n}\n\nexport default AuthRoute;\n","import App from \"./app\";\nconst app = new App();\n\napp.listen();\n\n\n\n\n\n\n// import express, { Application } from \"express\";\n// import cors from \"cors\";\n// import helmet from \"helmet\";\n// import morgan from \"morgan\";\n// import fs from \"fs\";\n// import path from \"path\";\n// import { createClient } from \"redis\";\n// import session from \"express-session\";\n// import connectRedis, { RedisStore } from \"connect-redis\";\n// import {\n//   NODE_ENV,\n//   PORT,\n//   REDIS_OPTIONS,\n//   SESSION_OPTIONS,\n// } from \"./config\";\n// import { RedisClientType } from \"@redis/client\";\n\n// class App {\n//   private app: Application;\n//   private port: number;\n//   private logPath: string = path.join(\n//     __dirname,\n//     \"..\",\n//     \"logs\",\n//     \"access.log\",\n//   );\n//   private redisStore: RedisStore;\n//   private redisClient: RedisClientType;\n\n//   constructor () {\n//     this.app = express();\n//     this.port = +PORT! || 4000;\n//     this.redisStore = connectRedis(session);\n//     this.redisClient = createClient(REDIS_OPTIONS);\n\n//     this.initializeMiddlewares();\n//     this.handleMiscRoutes();\n//   }\n\n//   public listen () {\n//     this.app.listen(this.port, () => {\n//       // eslint-disable-next-line no-console\n//       console.log(`Server is up on the port: ${this.port}`);\n//     });\n//   }\n\n//   private initializeMiddlewares () {\n//     this.app.use(cors());\n//     this.app.use(express.json());\n\n//     /**\n//      * Security headers to be attached with requests\n//      */\n//     this.app.use(helmet());\n\n//     /**\n//      * For log related services - only for dev server\n//      */\n//     if (NODE_ENV == \"development\" || NODE_ENV == \"test\") {\n//       const accessLogStream: fs.WriteStream = fs.createWriteStream(\n//         this.logPath,\n//         {\n//           flags: \"a\",\n//         },\n//       );\n//       this.app.use(\n//         morgan(\"common\", {\n//           stream: accessLogStream,\n//         }),\n//       );\n//     }\n//   }\n\n//   private handleMiscRoutes = () => {\n//     /**\n//      * Base route - to check API health\n//      */\n//     this.app.get(\"/\", (req, res) => {\n//       res.status(200).json({\n//         error: null,\n//         data: {\n//           server: \"Base-Healthy\",\n//         },\n//       });\n//     });\n\n//     /**\n//      * Handling all undefined routes\n//      */\n//     this.app.all(\"*\", (req, res) => {\n//       res.status(404).json({\n//         error: \"Requested route doesn't exist - 404\",\n//         data: null,\n//       });\n//     });\n//   };\n\n//   private configureRedis = () => {\n//     this.app.use(\n//       session({\n//         ...SESSION_OPTIONS,\n//         store: new this.redisStore({ client: this.redisClient }),\n//       }),\n//     );\n//   };\n// }\n\n// export default App;\n","import express, { Application } from \"express\";\nimport cors from \"cors\";\nimport helmet from \"helmet\";\nimport morgan from \"morgan\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport session from \"express-session\";\nimport { NODE_ENV, PORT, SESSION_OPTIONS } from \"./config\";\nimport ConfigureRedis from \"./services/redis/redis.service\";\nimport AuthRoute from \"./routes/auth/auth.route\";\nimport { GeneralApiResponse } from \"./interfaces\";\n\nclass App {\n  private app: Application;\n  private port: number;\n  private logPath: string = path.join(\n    __dirname,\n    \"..\",\n    \"logs\",\n    \"access.log\",\n  );\n  private redisStore;\n  private userAuthRoute;\n\n  constructor () {\n    this.app = express();\n    this.port = +PORT! || 4000;\n\n    //configuring redis and fetching the value of redisStore that is newly configured with express-session\n    this.redisStore = new ConfigureRedis().redisStore;\n    this.userAuthRoute = new AuthRoute();\n\n    this.initializeMiddlewares();\n    this.initializeRoutes();\n    this.handleMiscRoutes();\n    this.configureExpressSessionMiddleware();\n  }\n\n  public listen = (): void => {\n    this.app.listen(this.port, () => {\n      // eslint-disable-next-line no-console\n      console.log(`Server is up on the port: ${this.port}`);\n    });\n  };\n\n  /**\n   * To handle all middleware-related parts - making it modular to make it easier to test\n   */\n  private initializeMiddlewares = (): void => {\n    this.app.use(cors());\n    this.app.use(express.json());\n\n    /**\n     * Security headers to be attached with requests\n     */\n    this.app.use(helmet());\n\n    /**\n     * For log related services - only for dev server\n     */\n    if (NODE_ENV == \"development\" || NODE_ENV == \"test\") {\n      const accessLogStream: fs.WriteStream = fs.createWriteStream(\n        this.logPath,\n        {\n          flags: \"a\",\n        },\n      );\n      this.app.use(\n        morgan(\"common\", {\n          stream: accessLogStream,\n        }),\n      );\n    }\n  };\n\n  private initializeRoutes = (): void => {\n    this.app.use(\"/auth\", this.userAuthRoute.router);\n  };\n\n  private handleMiscRoutes = (): void => {\n    /**\n     * Base route - to check API health\n     */\n    this.app.get(\"/\", (req, res) => {\n      res.status(200).json({\n        error: null,\n        data: {\n          server: \"Base-Healthy\",\n        },\n      } as GeneralApiResponse);\n    });\n\n    /**\n     * Handling all undefined routes\n     */\n    this.app.all(\"*\", (req, res) => {\n      res.status(404).json({\n        error: \"Requested route doesn't exist - 404\",\n        data: null,\n      } as GeneralApiResponse);\n    });\n  };\n\n  /**\n   * Configuring a middleware for express session to work with redis cache\n   */\n  private configureExpressSessionMiddleware = (): void => {\n    this.app.use(\n      session({\n        ...SESSION_OPTIONS,\n\n        //making use of redisStore instantiated from cache service\n        store: this.redisStore,\n      }),\n    );\n  };\n}\n\nexport default App;\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","require","process","env","REDIS_PORT","REDIS_HOST","REDIS_PASSWORD","REDIS_OPTIONS","port","host","password","POSTGRESQL_USER","POSTGRESQL_PASSWORD","POSTGRESQL_PORT","POSTGRESQL_HOST","DATABASE_URL","SESSION_SECRET","SESSION_NAME","SESSION_TIMEOUT","SESSION_OPTIONS","secret","name","cookie","maxAge","secure","resave","saveUninitialized","rolling","PORT","config","ConfigureRedis","this","RedisStore","connectRedis","session","redisClient","Redis","on","client","i","AuthService","genSalt","salt","hash","hashedPassword","userPassword","dbPassword","compare","email","Promise","resolve","reject","prisma","user","findUnique","where","data","getUserFromEmail","error","code","encryptPassword","create","id","PrismaClient","AuthController","userRegistrationData","Joi","min","max","trim","required","lowercase","validate","req","res","body","validationError","validateRegistrationData","authService","register","status","json","userId","message","AuthRoute","router","path","post","authController","Router","initializeRoute","App","__dirname","app","listen","console","log","use","cors","express","helmet","userAuthRoute","server","all","store","redisStore","initializeMiddlewares","initializeRoutes","handleMiscRoutes","configureExpressSessionMiddleware"],"sourceRoot":""}